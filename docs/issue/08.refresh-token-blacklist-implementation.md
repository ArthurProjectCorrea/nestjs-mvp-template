# Feature Request

## üìã Feature Description

Implement a comprehensive refresh token blacklist system with Redis for enhanced security and session management in the authentication module. This feature includes token rotation, session limits, audit logging, and automatic cleanup to prevent token reuse and manage concurrent sessions effectively.

## üéØ Feature Type

<!-- Mark the relevant option with an "x" -->

- [ ] üöÄ **New API Endpoint** - New REST API functionality
- [x] üîê **Authentication/Authorization** - Auth-related features
- [x] üìä **Database/Model** - New entities or database features
- [x] üõ°Ô∏è **Security** - Security enhancements
- [ ] ‚ö° **Performance** - Performance improvements
- [ ] üîå **Integration** - Third-party service integration
- [x] üì± **API Enhancement** - Improvement to existing endpoints
- [ ] üé® **Developer Experience** - Tools, scripts, or DX improvements

## üí° Problem Statement

### Current Situation

The current authentication system lacks robust session management and token security features. Refresh tokens can be reused indefinitely, there are no limits on concurrent sessions, and there's no mechanism to revoke tokens immediately when needed. This poses security risks such as token theft exploitation and unmanaged session accumulation.

### Proposed Solution

Implement a refresh token blacklist system using Redis for fast lookups, combined with database persistence for audit trails. Include token rotation, session limits, automatic cleanup, and comprehensive audit logging to provide secure, scalable session management.

## üé® Feature Requirements

### Functional Requirements

- [x] Implement refresh token hashing and secure storage
- [x] Add Redis-based blacklist for revoked tokens
- [x] Enable refresh token rotation for enhanced security
- [x] Implement session limits per user
- [x] Add audit logging for authentication events
- [x] Create API endpoints for session management
- [x] Support device tracking and metadata storage

### Non-Functional Requirements

- [x] High performance with Redis for blacklist lookups
- [x] Automatic cleanup with TTL-based expiration
- [x] Scalable session management with sorted sets
- [x] Comprehensive error handling and validation
- [x] Backward compatibility during rollout

## üìê Technical Specifications

### API Design

#### New Endpoints

```typescript
// List active sessions for authenticated user
GET /auth/sessions
Authorization: Bearer <access_token>
Response: Array of session objects with metadata

// Revoke specific session
POST /auth/sessions/:id/revoke
Authorization: Bearer <access_token>
Body: { reason?: string }

// Logout from all sessions
POST /auth/logout-all
Authorization: Bearer <refresh_token>
Response: { message: string }
```

#### Enhanced Existing Endpoints

```typescript
// Login endpoint with device tracking
POST /auth/login
{
  "email": "user@example.com",
  "password": "password"
}
Response: {
  "accessToken": "jwt...",
  "refreshToken": "refresh...",
  "expiresAt": "2025-10-09T...",
  "sessionId": 123
}

// Refresh token endpoint with rotation
POST /auth/refresh
{
  "refreshToken": "refresh_token_here"
}
Response: {
  "accessToken": "new_jwt...",
  "refreshToken": "new_refresh...",
  "expiresAt": "2025-10-09T..."
}
```

### Database Changes

#### New Models

```prisma
model Token {
  id               Int       @id @default(autoincrement())
  userId           Int
  refreshTokenHash String    @unique
  jti              String    @unique // JWT ID for access token
  ip               String?
  userAgent        String?
  deviceName       String?   // optional (e.g., "Chrome on MacBook")
  location         String?   // optional (city/country if resolved)
  isRevoked        Boolean   @default(false)
  createdAt        DateTime  @default(now())
  expiresAt        DateTime
  lastUsedAt       DateTime? // last time refresh was used
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model AuditLog {
  id        Int      @id @default(autoincrement())
  userId    Int?
  event     String   // 'LOGIN', 'LOGIN_FAIL', 'REFRESH', 'LOGOUT', 'REVOKE', ...
  ip        String?
  meta      Json?    // extra info (userAgent, reason, token jti, etc.)
  createdAt DateTime @default(now())
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
}
```

#### Migration Command

```bash
npx prisma migrate dev --name add_token_and_auditlog
```

### Environment Variables

Add to `.env`:

```
JWT_SECRET=your_jwt_secret_here
JWT_EXPIRES_IN=15m
REFRESH_SECRET=your_refresh_secret_here
REFRESH_EXPIRES_IN=30d

REDIS_HOST=127.0.0.1
REDIS_PORT=6379
MAX_SESSIONS_PER_USER=5
ROTATE_REFRESH_TOKENS=true  # true = rotating refresh tokens
```

### Dependencies

Install required packages:

```bash
pnpm add ioredis crypto-js date-fns
pnpm add -D @types/ioredis
```

## üß™ Acceptance Criteria

### Core Functionality

- [x] Refresh tokens are hashed and stored securely in database
- [x] Redis blacklist prevents reuse of revoked tokens
- [x] Token rotation creates new refresh tokens on use
- [x] Session limits revoke oldest sessions when exceeded
- [x] Audit logs record all authentication events
- [x] API endpoints work for session management
- [x] Device metadata is captured and stored

### Quality Assurance

- [x] Unit tests cover all new functionality (minimum 80% coverage)
- [x] E2E tests validate complete authentication workflows
- [x] Code follows project style guidelines and conventions
- [x] Documentation is updated (API docs, README, etc.)

### Security & Performance

- [x] Security review completed for token handling
- [x] Performance impact assessed with Redis integration
- [x] Rate limiting applied to authentication endpoints
- [x] Input sanitization implemented for all inputs

## üì∏ Mockups / Examples

### Authentication Flow Example

```json
{
  "login_request": {
    "email": "user@example.com",
    "password": "secure_password"
  },
  "login_response": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "a1b2c3d4e5f6...",
    "expiresAt": "2025-10-09T10:15:00.000Z",
    "sessionId": 123
  },
  "sessions_list": [
    {
      "id": 123,
      "deviceName": "Chrome on Windows",
      "ip": "192.168.1.100",
      "userAgent": "Mozilla/5.0...",
      "createdAt": "2025-10-09T09:00:00.000Z",
      "lastUsedAt": "2025-10-09T09:15:00.000Z"
    }
  ]
}
```

## üîó Related Issues

<!-- Link related issues or dependencies -->

- Related to: #06.create-refresh-token-blacklist-feature-request.md
- Depends on: Authentication module implementation

## üöÄ Implementation Notes

### Development Approach

1. **Phase 1**: Database schema and Redis setup
2. **Phase 2**: Core authentication service updates
3. **Phase 3**: API endpoints and testing

### Technical Considerations

- Redis keys use structured naming: `bl:access:<jti>`, `bl:refresh:<hash>`, `sessions:<userId>`
- TTL values match token expiration times for automatic cleanup
- Hash tokens using SHA-256 for secure storage
- Implement pipeline operations for Redis performance

### Breaking Changes

- [x] **Minor breaking changes** (describe below)

Breaking changes include new required environment variables and updated token response formats. Migration path involves updating environment configuration and handling new token fields.

## üéØ Priority

<!-- Mark the priority level -->

- [x] üî¥ **Critical** - Blocks other work or critical business need
- [ ] üü° **High** - Important for next release
- [ ] üü¢ **Medium** - Nice to have in upcoming releases
- [ ] üîµ **Low** - Future enhancement

## üìÖ Timeline

<!-- Estimated timeline or target release -->

- **Target Release**: v1.0.0
- **Estimated Effort**: 2-3 weeks
- **Dependencies**: Redis infrastructure setup

## üìù Additional Context

### Security Design

- **Never store refresh tokens in plain text**: Store SHA-256 hash for secure comparison
- **Access tokens include unique JTI**: Each token has unique identifier for blacklist tracking
- **Blacklist in Redis**: Fast lookups with TTL for automatic cleanup
- **Token rotation**: New refresh token issued on each use, old token revoked
- **Multi-session support**: Track active sessions with configurable limits

### Redis Key Design

- `bl:access:<jti>` => "1" (TTL = remaining access token lifetime)
- `bl:refresh:<refreshHash>` => "1" (TTL = remaining refresh token lifetime)
- `sessions:<userId>` => sorted set with token IDs (score = timestamp)
- `session:token:<tokenId>` => hash with session metadata

### Rollout Plan

1. Apply Prisma migration for new schema
2. Provision Redis in staging and production
3. Deploy AuthService updates with backward compatibility
4. Enable token rotation after compatibility testing
5. Monitor authentication metrics and error rates

### Testing Checklist

- [x] Login creates access + refresh tokens
- [x] Access token validation with blacklist check
- [x] Refresh token rotation and old token invalidation
- [x] Logout revokes refresh and blacklists access
- [x] Multi-session limit enforcement
- [x] Audit logging for all events
- [x] Redis cleanup with TTL expiration

### Research

- JWT Best Current Practices (RFC 8725)
- Redis security and performance patterns
- OAuth 2.0 Token Revocation standards

### Alternatives Considered

- Database-only blacklist (slower performance)
- In-memory blacklist (not scalable)
- External token store (increased complexity)

---
