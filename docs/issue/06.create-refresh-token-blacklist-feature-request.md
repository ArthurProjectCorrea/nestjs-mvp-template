# Feature Request

## 📋 Feature Description

Add a session management subsystem to the authentication flow that provides secure refresh token handling and token revocation (blacklist). This includes a persistent refresh-token store, token revocation endpoints, and short-lived access tokens to enable corporate-grade session control.

## 🎯 Feature Type

- [x] 🔐 **Authentication/Authorization** - Auth-related features
- [x] 📊 **Database/Model** - New entity for tokens
- [x] 🚀 **New API Endpoint** - Endpoints for refresh, logout and session management

## 💡 Problem Statement

### Current Situation

- Short-lived JWTs are used for authorization.
- No persistent refresh token storage or revocation mechanism exists.
- Logout cannot guarantee token invalidation.

### Proposed Solution

Implement a token management system using a new `Token` model persisted by Prisma. Introduce endpoints to issue refresh tokens, rotate and revoke them, and revoke all tokens for a user. Use short-lived access tokens (e.g., 15 minutes) and long-lived refresh tokens stored server-side with a revocation flag and expiration timestamp.

## 🎨 Feature Requirements

### Functional Requirements

- [x] On successful login, issue an access token (JWT) and a server-stored refresh token.
- [x] Provide an endpoint to exchange a refresh token for new access + refresh tokens (refresh rotation recommended).
- [x] Provide an endpoint to revoke a single refresh token (logout).
- [x] Provide an authenticated endpoint to revoke all active tokens for the requesting user (global logout).
- [x] Persist refresh tokens with associated metadata (user, issuedAt, expiresAt, isRevoked).

### Non-Functional Requirements

- [x] Implementation must be testable and include unit and E2E tests.

## 📐 Technical Specifications

### API Design

**POST /auth/login**

- Request: `{ email, password }`
- Response: `{ accessToken, refreshToken, user }`

**POST /auth/refresh**

- Request: `{ refreshToken }`
- Response: `{ accessToken, refreshToken }`

**POST /auth/logout**

- Request: `{ refreshToken }`
- Response: `{ message }`

**POST /auth/logout-all (authenticated)**

- Request: none (uses authenticated user)
- Response: `{ message }`

### Database Changes

Add a new Prisma model to `schema.prisma`:

```prisma
model Token {
  id           Int      @id @default(autoincrement())
  userId       Int
  refreshToken String   @unique
  isRevoked    Boolean  @default(false)
  createdAt    DateTime @default(now())
  expiresAt    DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}
```

After schema changes run (development):

```bash
npx prisma migrate dev --name add_token_table
```

### Configuration / Environment

Add the following environment variables (example):

```env
JWT_SECRET=supersecreto123
JWT_EXPIRES_IN=15m
REFRESH_SECRET=superrefresh456
REFRESH_EXPIRES_IN=7d
```

### Implementation Notes

- Implement token creation in `AuthService.generateTokens()`.
- For `logout-all`, update all tokens for the user and mark them revoked.

## 🧪 Acceptance Criteria

### Core Functionality

- [x] Login returns access and refresh tokens and persists the refresh token record.
- [x] Refresh endpoint validates refresh token, rejects revoked or expired tokens, and issues new tokens.
- [x] Logout endpoint revokes the specified refresh token.
- [x] Logout-all endpoint revokes all non-revoked tokens for the authenticated user.

### Quality Assurance

- [x] Unit tests for AuthService flows (login, refresh, logout, revokeUserTokens).
- [x] E2E tests covering login → refresh → use access token to access protected endpoint.
- [x] Code follows project style and passes lint/format checks.

### Security & Performance

- [x] No secrets are committed; tokens treated as sensitive in logs.
- [x] Refresh rotation implemented to limit reuse.

## 📸 Mockups / Examples

Example token creation (response):

```json
{
  "accessToken": "eyJhbGciOi...",
  "refreshToken": "b3f5a9...",
  "user": {
    "id": 1,
    "name": "Alice",
    "email": "alice@example.com",
    "role": "user"
  }
}
```

## 🔗 Related Issues

- Depends on: #04.create-corporate-authentication-mvp-feature-request (authentication foundation)

## 🚀 Implementation Notes

### Development Approach

1. Add Prisma model and run migration locally.
2. Implement token persistence CRUD in a `TokenService` or inside `AuthService`.
3. Implement endpoints in `AuthController` (`/auth/refresh`, `/auth/logout`, `/auth/logout-all`).
4. Add unit and E2E tests.
5. Add documentation to `docs/wiki/Authentication.md` with examples and migration steps.

### Technical Considerations

- Consider using refresh token rotation: revoke old token after issuing new one.
- Optionally store device metadata (IP, user-agent) to support per-device session management in future.

### Breaking Changes

- [x] **Minor breaking changes** (describe below)

If rolling out token table and logic, clients must handle refresh-token rotation and call the `/auth/refresh` endpoint when access tokens expire. Update client apps to persist the server-issued refresh token securely.

## 🎯 Priority

- [ ] 🔴 **Critical** - Blocks other work or critical business need
- [x] 🟡 **High** - Important for next release
- [ ] 🟢 **Medium** - Nice to have in upcoming releases
- [ ] 🔵 **Low** - Future enhancement

## 📅 Timeline

- **Target Release**: v0.2.0
- **Estimated Effort**: 2-4 days (including tests)
- **Dependencies**: Prisma migration, updated env configuration

## 📝 Additional Context

### Research

- Token revocation is implemented server-side by persisting refresh tokens and a revocation flag.
- Rotation reduces replay risk: once a refresh token is used it is invalidated and replaced.

### Alternatives Considered

- Stateless refresh tokens (JWT) — rejected because they cannot be revoked server-side without additional blacklist cache.
- Redis-backed blacklist — future improvement for distributed invalidation and performance.

---
